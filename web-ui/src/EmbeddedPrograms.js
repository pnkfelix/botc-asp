// Auto-generated by scripts/embed-lp.js - do not edit manually
// Run 'npm run embed-lp' to regenerate

export const botcLp = "% Time points for the game\n% We use structured time: night(N, RoleOrder, Substep)\n% night(1, 0, 0) is the setup state before any role acts\n% night(1, R, S) is substep S of the role at position R in the night order\n\ntime(night(1, 0, 0)).  % setup state before any actions on night 1\n\n% Generate time for roles that are actually assigned\ntime(night(1, RoleOrd, S)) :-\n    first_night_role_order(Role, RoleOrd),\n    first_night_substep(Role, S, _),\n    assigned(0, _, Role).\n\n% Also generate time for roles that players THINK they are (e.g., Drunk thinks they're Empath)\n% This is needed because the ST still \"wakes\" them and gives them (fake) info\ntime(night(1, RoleOrd, S)) :-\n    first_night_role_order(Role, RoleOrd),\n    first_night_substep(Role, S, _),\n    received(_, Role).\n\n% Other nights (2+) use other_night_role_order and other_night_substep\n% night_number/1 defines which nights we're modeling\n% Tests/instances can add needs_night(N) to request modeling of night N;\n% all nights from 1 to N will be included automatically.\nnight_number(1).  % always model night 1\nnight_number(N) :- needs_night(N).  % include any explicitly requested night\nnight_number(N) :- night_number(N+1), N >= 1.  % fill in all nights below\n\ntime(night(N, 0, 0)) :- night_number(N), N > 1.  % setup state for other nights\n\ntime(night(N, RoleOrd, S)) :-\n    night_number(N), N > 1,\n    other_night_role_order(Role, RoleOrd),\n    other_night_substep(Role, S, _),\n    assigned(0, _, Role).\n\ntime(night(N, RoleOrd, S)) :-\n    night_number(N), N > 1,\n    other_night_role_order(Role, RoleOrd),\n    other_night_substep(Role, S, _),\n    received(_, Role).\n\n% Which role is acting at a given time point\n% Includes both assigned roles and roles players think they are (received tokens)\nacting_role(night(1, RoleOrd, S), Role) :-\n    first_night_role_order(Role, RoleOrd),\n    first_night_substep(Role, S, _),\n    assigned(0, _, Role).\n\nacting_role(night(1, RoleOrd, S), Role) :-\n    first_night_role_order(Role, RoleOrd),\n    first_night_substep(Role, S, _),\n    received(_, Role).\n\nacting_role(night(N, RoleOrd, S), Role) :-\n    night_number(N), N > 1,\n    other_night_role_order(Role, RoleOrd),\n    other_night_substep(Role, S, _),\n    assigned(0, _, Role).\n\nacting_role(night(N, RoleOrd, S), Role) :-\n    night_number(N), N > 1,\n    other_night_role_order(Role, RoleOrd),\n    other_night_substep(Role, S, _),\n    received(_, Role).\n\n% Ordering: next(T1, T2) means T2 immediately follows T1\n% Ordering is just numeric comparison on (RoleOrder, Substep) within same night\nnext(T1, T2) :-\n    time(T1), time(T2),\n    T1 = night(N, R1, S1),\n    T2 = night(N, R2, S2),\n    (R1, S1) < (R2, S2),\n    not between(T1, T2).\n\n% between(T1, T2) is true if there's some T3 strictly between T1 and T2\nbetween(T1, T2) :-\n    time(T1), time(T2), time(T3),\n    T1 = night(N, R1, S1),\n    T2 = night(N, R2, S2),\n    T3 = night(N, R3, S3),\n    (R1, S1) < (R3, S3),\n    (R3, S3) < (R2, S2).\n\n% Phase transitions: night -> day -> night\n% The final time of night N transitions to day(N, 0)\nnext(T, day(N, 0)) :- final_night_time(N, T), day_number(N).\n\n% Within a day: day(N, 0) -> day(N, exec)\nnext(day(N, 0), day(N, exec)) :- day_number(N).\n\n% Day N ends, night N+1 begins\nnext(day(N, exec), night(N+1, 0, 0)) :- day_number(N), night_number(N+1).\n\nplayer(P) :- name(P), chair(P,C), C < player_count.\n\n% Game chair: only chairs for players actually in this game\ngame_chair(P, C) :- player(P), chair(P, C).\n\n% Circular seating adjacency\n% Two players are neighbors if their chairs are adjacent (mod player_count)\nneighbor(P1, P2) :-\n    player(P1), player(P2),\n    chair(P1, C1), chair(P2, C2),\n    C2 = (C1 + 1) \\ player_count.\n\n% neighbor is symmetric\nneighbor(P1, P2) :- neighbor(P2, P1).\n\n% Order two players by chair number (smaller chair first)\n% Used to normalize player order in info tuples so position doesn't leak info\nchair_ordered(P1, P2, P1, P2) :- player(P1), player(P2), chair(P1, C1), chair(P2, C2), C1 < C2.\nchair_ordered(P1, P2, P2, P1) :- player(P1), player(P2), chair(P1, C1), chair(P2, C2), C1 > C2.\n\n% ===========================================================================\n% Alive vs Publicly Alive\n% ===========================================================================\n% alive(P, T) = true dead/alive state (what ST knows, used for game mechanics)\n% publicly_alive(P, T) = what players see (death shroud not yet placed)\n%\n% During the night, a player killed by the demon has imp_dead token.\n% They are dead (for ability purposes) but publicly_alive (shroud placed at dawn).\n\n% A player is dead (from ST perspective) if they have a \"dead tonight\" token\n% Note: imp_dead specifically is handled in tb.lp to account for protection\n% Other death tokens could be added here as needed\n% dead(P, T) :- reminder_on(some_other_death_token, P, T).\n\n% publicly_alive = alive and not yet revealed as dead\n% (The public death shroud is placed at dawn, so during night they look alive)\npublicly_alive(P, T) :- alive(P, T).\n\n% ===========================================================================\n% Living neighbors: the closest alive player in each direction\n% Used by Empath and potentially other roles\n% These use `alive` (ST perspective) not `publicly_alive`\n% ===========================================================================\n\n% clockwise_distance(P1, P2, D) = going clockwise from P1, P2 is D seats away\nclockwise_distance(P1, P2, D) :-\n    player(P1), player(P2), P1 != P2,\n    chair(P1, C1), chair(P2, C2),\n    D = (C2 - C1 + player_count) \\ player_count.\n\n% living_neighbor(P1, P2, T) means P2 is a living neighbor of P1 at time T\n% P2 is a living neighbor if they're alive (not dead) and no one closer is alive\n\n% Clockwise living neighbor: closest alive player going clockwise\nliving_neighbor_clockwise(P1, P2, T) :-\n    player(P1), player(P2), P1 != P2,\n    time(T),\n    alive(P2, T),\n    not dead(P2, T),\n    clockwise_distance(P1, P2, D),\n    not closer_alive_clockwise(P1, P2, D, T).\n\n% There's a closer alive (and not dead) player clockwise\ncloser_alive_clockwise(P1, P2, D, T) :-\n    player(P1), player(P2), player(P3),\n    P1 != P2, P1 != P3, P2 != P3,\n    time(T),\n    alive(P3, T),\n    not dead(P3, T),\n    clockwise_distance(P1, P2, D),\n    clockwise_distance(P1, P3, D3),\n    D3 < D.\n\n% Counter-clockwise living neighbor: closest alive player going counter-clockwise\n% This is equivalent to clockwise with reversed direction\nliving_neighbor_counterclockwise(P1, P2, T) :-\n    living_neighbor_clockwise(P2, P1, T).\n\n% A player's living neighbors are the closest alive player in each direction\nliving_neighbor(P1, P2, T) :- living_neighbor_clockwise(P1, P2, T).\nliving_neighbor(P1, P2, T) :- living_neighbor_counterclockwise(P1, P2, T).\n\n% Reminder token inertia: once placed, tokens persist to the next time point\n% (unless explicitly removed via token_removed)\nreminder_on(Token, P, T2) :- reminder_on(Token, P, T1), next(T1, T2), not token_removed(Token, P, T2).\n\n% A player is impaired at time T if they have a token that causes impairment\nimpaired(P, T) :- reminder_on(Token, P, T), causes_impairment(Token).\n\n% A player's ability is \"functioning\" if they're not impaired\nfunctioning(P, T) :- player(P), time(T), not impaired(P, T).\n\n% ===========================================================================\n% Night communication vocabulary\n% These are the signals available for ST <-> player communication at night\n% ===========================================================================\n\n% Binary signals\nsignal(yes).\nsignal(no).\n\n% Alignment signals\nsignal(good).\nsignal(evil).\n\n% Numeric counts (0 through max possible)\nsignal(count(N)) :- N = 0..player_count.\n\n% Pointing to a player\nsignal(point(P)) :- player(P).\n\n% Pointing to a role on the script\nsignal(point(R)) :- role(R).\n\n% st_tells_core(Role, Player, Message, T) - ST communicates Message to Player\n% as part of Role's ability at time T. This is the detailed/implementation form.\n\n% Constraint: st_tells_core for a role can only go to players who think they have\n% that role (i.e., received that role's token). This covers both:\n% 1. Players who actually have the role\n% 2. Players who think they have it (e.g., Drunk with chef token)\n% NOTE: This will need adjustment for Philosopher (gains another role's ability),\n% Pixie (gains ability after townsfolk dies), and Pit Hag (can change roles mid-game).\n:- st_tells_core(R, P, _, _), not received(P, R).\n\n% Constraint: a player can only receive one message from a role at a given time.\n% Roles that communicate multiple pieces of info (e.g., Washerwoman pointing to\n% two players and naming a role) use tuple values like info(P1, P2, Role).\n% Using aggregate instead of pairwise comparison to avoid grounding explosion.\n:- st_tells_core(R, P, _, T), #count { V : st_tells_core(R, P, V, T) } > 1.\n\n% ===========================================================================\n% Simplified st_tells predicates for player-visible information\n% These drop implementation details (player identity, exact timing) and expose\n% what players actually observe in a simplified form.\n% ===========================================================================\n\n% --- Binary st_tells/2: for one-time info or when night doesn't matter ---\n\n% For count info (chef, empath): st_tells(chef, 2) instead of st_tells(chef, count(2))\nst_tells(R, N) :- st_tells_core(R, _, count(N), _).\nst_tells(P, N) :- st_tells_core(_, P, count(N), _).\n\n% For info tuples (washerwoman, librarian, investigator): extract the role shown\n% st_tells(washerwoman, chef) means \"washerwoman was told about a chef\"\nst_tells(R, Role) :- st_tells_core(R, _, info(_, _, Role), _).\nst_tells(P, Role) :- st_tells_core(_, P, info(_, _, Role), _).\n\n% For point info (undertaker, ravenkeeper): st_tells(undertaker, poisoner)\nst_tells(R, Role) :- st_tells_core(R, _, point(Role), _).\nst_tells(P, Role) :- st_tells_core(_, P, point(Role), _).\n\n% For yes/no (fortune_teller): already simple, pass through directly\nst_tells(R, yes) :- st_tells_core(R, _, yes, _).\nst_tells(R, no) :- st_tells_core(R, _, no, _).\nst_tells(P, yes) :- st_tells_core(_, P, yes, _).\nst_tells(P, no) :- st_tells_core(_, P, no, _).\n\n% --- Ternary st_tells/3: includes night number for recurring info roles ---\n% Use this for empath, fortune_teller, or any role that gets info multiple nights.\n% Format: st_tells(RoleOrPlayer, Info, NightNum)\n\n% For count info with night: st_tells(empath, 1, 2) = \"empath told 1 on night 2\"\nst_tells(R, N, Night) :- st_tells_core(R, _, count(N), night(Night, _, _)).\nst_tells(P, N, Night) :- st_tells_core(_, P, count(N), night(Night, _, _)).\n\n% For yes/no with night: st_tells(fortune_teller, yes, 3) = \"FT told yes on night 3\"\nst_tells(R, yes, Night) :- st_tells_core(R, _, yes, night(Night, _, _)).\nst_tells(R, no, Night) :- st_tells_core(R, _, no, night(Night, _, _)).\nst_tells(P, yes, Night) :- st_tells_core(_, P, yes, night(Night, _, _)).\nst_tells(P, no, Night) :- st_tells_core(_, P, no, night(Night, _, _)).\n\n% For point info with night (undertaker gets info on night after execution)\nst_tells(R, Role, Night) :- st_tells_core(R, _, point(Role), night(Night, _, _)).\nst_tells(P, Role, Night) :- st_tells_core(_, P, point(Role), night(Night, _, _)).\n\n% player_chooses(Role, Player, Choice, T) - Player communicates Choice to ST\n% as part of Role's ability at time T (in response to ST's request)\n\n% Categories for registration (role type and alignment)\ncategory(townsfolk).\ncategory(outsider).\ncategory(minion).\ncategory(demon).\ncategory(good).\ncategory(evil).\n\n% Actual categories of a player based on their assigned role\nactual_category(P, townsfolk) :- assigned(0, P, R), townsfolk(R).\nactual_category(P, outsider) :- assigned(0, P, R), outsider(R).\nactual_category(P, minion) :- assigned(0, P, R), minion(R).\nactual_category(P, demon) :- assigned(0, P, R), demon(R).\nactual_category(P, good) :- assigned(0, P, R), townsfolk(R).\nactual_category(P, good) :- assigned(0, P, R), outsider(R).\nactual_category(P, evil) :- assigned(0, P, R), minion(R).\nactual_category(P, evil) :- assigned(0, P, R), demon(R).\n\n% Default: register as what you actually are (for players who can't mis-register)\nregisters_as(P, C, T) :- actual_category(P, C), time(T), not may_mis_register(P).\n\n% Mid-game role changes: register based on currently assigned role\n% If assigned a demon role at day N, register as demon for all times after day N\nregisters_as(P, demon, T) :-\n    assigned(N, P, R), demon(R), N > 0,\n    time(T), T = night(N2, _, _), N2 > N.\nregisters_as(P, demon, T) :-\n    assigned(N, P, R), demon(R), N > 0,\n    time(T), T = day(N2, _), N2 > N.\n\n% If a player may mis-register, ST chooses for each category they may misregister as\n{ registers_as(P, C, T) } :- may_misregister_as(P, C), time(T).\n\n% Players who can mis-register can also choose to register as their actual category\n% (this is not misregistration, just being truthful)\n{ registers_as(P, C, T) } :- actual_category(P, C), time(T), may_mis_register(P).\n\n% Players who can mis-register must still register as at least one role category\n:- player(P), time(T), may_mis_register(P),\n   not registers_as(P, townsfolk, T), not registers_as(P, outsider, T),\n   not registers_as(P, minion, T), not registers_as(P, demon, T).\n\n% Players who can mis-register must still register as at least one alignment\n:- player(P), time(T), may_mis_register(P),\n   not registers_as(P, good, T), not registers_as(P, evil, T).\n\n% outsider_adjustment(A) :- A = #sum { N, R: causes_outsider_mod(R, N), distrib(R) }.\noutsider_adjustment(A) :- A = #sum { N, R: causes_outsider_mod(R, N), assigned(0, _, R) }.\n\nminion_adjustment(A) :- A = #sum { N, R: causes_minion_mod(R, N), assigned(0, _, R) }.\ndemon_adjustment(A) :- A = #sum { N, R: causes_demon_mod(R, N), assigned(0, _, R) }.\n\ncauses_townsfolk_mod(R, -N) :- causes_outsider_mod(R, N).\n\ncauses_minion_mod(none, 0) :- #false.\ncauses_demon_mod(none, 0) :- #false.\n\ntownsfolk_adjustment(A) :- A = #sum { N, R: causes_townsfolk_mod(R, N), assigned(0, _, R) }.\n\nadjusted_townsfolk(B + A) :- base_townsfolk(B), townsfolk_adjustment(A).\nadjusted_outsider(B + A) :- base_outsider(B), outsider_adjustment(A).\nadjusted_minion(B + A) :- base_minion(B), minion_adjustment(A).\nadjusted_demon(B + A) :- base_demon(B), demon_adjustment(A).\n\nrole(X) :- townsfolk(X).\nrole(X) :- outsider(X).\nrole(X) :- minion(X).\nrole(X) :- demon(X).\n\nreminder(poi_poisoned).\n\n% the legal baseline role distrbutions are:\n% 7 players => 1 demon, 1 minion, 0 outsiders, 5 townsfolk\n\nbase_townsfolk(5) :- 7 <= player_count <= 9.\nbase_townsfolk(7) :- 10 <= player_count <= 12.\nbase_townsfolk(9) :- 13 <= player_count <= 15.\n\nbase_outsider(player_count - 7) :- 7 <= player_count <= 9.\nbase_outsider(player_count - 10) :- 10 <= player_count <= 12.\nbase_outsider(player_count - 13) :- 13 <= player_count <= 15.\n\nbase_minion(1) :-  7 <= player_count <= 9.\nbase_minion(2) :- 10 <= player_count <= 12.\nbase_minion(3) :- 13 <= player_count <= 15.\n\nbase_demon(1).\n\ndistrib(R) :- assigned(0, _, R).\n%{distrib(X) : demon(X)} = 1.\n%{distrib(X) : minion(X)} = 1    :- 7 <= player_count <= 9.\n%{distrib(X) : townsfolk(X)} = 5 - A :- 7 <= player_count <= 9, outsider_adjustment(A).\n%{distrib(X) : outsider(X)} = player_count - 7 + A :- 7 <= player_count <= 9, outsider_adjustment(A).\n%\n%{distrib(X) : minion(X)} = 2    :- 10 <= player_count <= 12.\n%{distrib(X) : townsfolk(X)} = 7 - A :- 10 <= player_count <= 12, outsider_adjustment(A).\n%{distrib(X) : outsider(X)} = player_count - 10 + A :- 10 <= player_count <= 12, outsider_adjustment(A).\n%\n%{distrib(X) : minion(X)} = 3    :- 13 <= player_count <= 15.\n%{distrib(X) : townsfolk(X)} = 9 :- 13 <= player_count <= 15.\n%{distrib(X) : outsider(X)} = player_count - 13 + A :- 13 <= player_count <= 15, outsider_adjustment(A).\n\n% belt+suspenders: the number of distributed roles must equal player count\n%:- not {distrib(X)} = player_count.\n\n% most roles can be in the bag (except things like drunk, marionette).\n{bag(X) : role(X), not never_in_bag(X)} = player_count.\n\n% each player receives exactly one token from the bag.\n{received(P, X) : bag(X)} = 1 :- player(P).\n% a token is not received by multiple players\n:- received(P1, X), received(P2, X), P1 != P2.\n\n% each player is assigned exactly one unique role\n{ assigned(0, P, R) : role(R) } = 1 :- player(P).\nR1 != R2 :- assigned(0, P1, R1), assigned(0, P2, R2), P1 != P2.\n\n%{assigned(0, P, X) : player(P), distrib(X)} = player_count.\n%R1 = R2 :- assigned(0, P, R1), assigned(0, P, R2).\n%R1 != R2 :- assigned(0, P1, R1), assigned(0, P2, R2), P1 != P2.\n\nthinks_it_is(X, X) :- role(X), not mistaken_identity(X, _).\nthinks_it_is(R, Y) :- mistaken_identity(R, townsfolk), townsfolk(Y).\nthinks_it_is(R, Y) :- mistaken_identity(R, demon), demon(Y).\nthinks_it_is(R, Y) :- mistaken_identity(R, minion), minion(Y).\n\n% the role assigned is one that \"thinks it is the\" token received.\n% NOTE: Only checks initial assignment (time 0). Mid-game role changes like\n% Scarlet Woman becoming Imp are not constrained by this. If we need to track\n% current role at arbitrary times, we may need a current_role(P, R, T) fluent.\n:- received(P, T), assigned(0, P, R), not thinks_it_is(R, T).\n\n:- adjusted_townsfolk(N), #count { R : assigned(0, _, R), townsfolk(R) } != N.\n:- adjusted_outsider(N), #count { R : assigned(0, _, R), outsider(R) } != N.\n:- adjusted_minion(N), #count { R : assigned(0, _, R), minion(R) } != N.\n:- adjusted_demon(N), #count { R : assigned(0, _, R), demon(R) } != N.\n\n% ===========================================================================\n% Day Phase - Simplified\n% We only track: reminder tokens, executions, and deaths\n% Nominations and voting details are abstracted away\n% ===========================================================================\n\n% day_number/1 defines which days we're modeling (like night_number)\n% Each day N follows night N, so we model the same range as nights\nday_number(N) :- night_number(N).\n\n% Everyone is alive at the start of the game\nalive(P, night(1, 0, 0)) :- player(P).\n\n% Alive status persists through night unless killed or dead\nalive(P, T2) :- alive(P, T1), next(T1, T2), not died(P, T1), not dead(P, T2).\n\n% Alive at start of day = alive at end of preceding night (unless they died that night)\n% Note: dead(P, T) handles imp_dead token deaths during the night\nalive(P, day(N, 0)) :- alive(P, T), final_night_time(N, T), not died(P, T), not dead(P, T).\n\n% Helper: find the final time point of a night\nfinal_night_time(N, T) :-\n    time(T), T = night(N, _, _),\n    not next(T, T2) : time(T2), T2 = night(N, _, _).\n\n% Alive at start of night N+1 = alive at end of day N\nalive(P, night(N+1, 0, 0)) :- alive(P, day(N, exec)), night_number(N+1).\n\n% ===========================================================================\n% Day Time Structure (simplified)\n% day(N, Phase) where Phase is:\n%   0 = start of day\n%   exec = end of day (execution happens here)\n% ===========================================================================\n\nday_time(day(N, 0)) :- day_number(N).\nday_time(day(N, exec)) :- day_number(N).\n\n% Time includes day times\ntime(T) :- day_time(T).\n\n% Alive at end of day = alive at start, minus anyone who died during day\nalive(P, day(N, exec)) :- alive(P, day(N, 0)), not died_during_day(P, N).\n\n% Helper: died during day N\ndied_during_day(P, N) :- died(P, day(N, _)).\n\n% ===========================================================================\n% Execution and Death\n% executed(Player, Day) - INPUT: who was executed on this day\n% died(Player, Time) - derived from execution or other effects\n% ===========================================================================\n\n% A player dies when executed\ndied(P, day(N, exec)) :- executed(P, N).\n\n% Validate: executed player must have been alive at start of day\n:- executed(P, N), not alive(P, day(N, 0)).\n\n% ===========================================================================\n% Grimoire State (for rendering)\n% These predicates provide a clean interface for a frontend to render the\n% grimoire at any point in time with minimal deduction.\n% ===========================================================================\n\n% grimoire_token(Player, RoleToken, Time) - what role token to display for a player\n% This is the token they received (what they think they are), not their true role.\n% A Drunk with the Chef token should display as Chef.\ngrimoire_token(P, R, T) :- received(P, R), time(T).\n\n% grimoire_reminder(Player, ReminderToken, Time) - which reminder tokens to show\ngrimoire_reminder(P, Token, T) :- reminder_on(Token, P, T).\n\n% grimoire_alive(Player, Time) - whether the player is alive\ngrimoire_alive(P, T) :- alive(P, T).\n\n% grimoire_true_role(Player, Role) - the player's actual role (ST view only)\n% This is for the ST's knowledge, not displayed on tokens.\ngrimoire_true_role(P, R) :- assigned(0, P, R).\n";
export const tbLp = "% drunk token is not allowed in the bag.\nnever_in_bag(drunk).\nmistaken_identity(drunk, townsfolk).\n\n% Drunk is always impaired - place \"Is the Drunk\" reminder token\nreminder_on(drunk_is_drunk, P, T) :- assigned(0, P, drunk), time(T), alive(P, T).\ncauses_impairment(drunk_is_drunk).\n\ntownsfolk(X) :- tb_townsfolk(X).\noutsider(X) :- tb_outsider(X).\nminion(X) :- tb_minion(X).\ndemon(X) :- tb_demon(X).\n\ntb_townsfolk(washerwoman; librarian; investigator; chef; empath; fortune_teller; undertaker; monk; ravenkeeper; virgin; slayer; soldier; mayor).\ntb_outsider(butler; drunk; recluse; saint).\n\ntb_minion(poisoner; spy; scarlet_woman; baron).\ntb_demon(imp).\n\ncauses_outsider_mod(baron, 2).\n\n% First Night Order for Trouble Brewing\n% Role order determines which role acts when\nfirst_night_role_order(poisoner, 1).\nfirst_night_role_order(washerwoman, 2).\nfirst_night_role_order(librarian, 3).\nfirst_night_role_order(investigator, 4).\nfirst_night_role_order(chef, 5).\nfirst_night_role_order(empath, 6).\nfirst_night_role_order(fortune_teller, 7).\nfirst_night_role_order(butler, 8).\nfirst_night_role_order(spy, 9).\n\n% Substeps for each role's first night actions\n% first_night_substep(Role, Substep, Action)\n\n% Poisoner: asks who to poison, player chooses, ST places token\nfirst_night_substep(poisoner, 1, st_asks(choose_target)).\nfirst_night_substep(poisoner, 2, player_chooses(target)).\nfirst_night_substep(poisoner, 3, st_places(poisoned)).\n\nother_night_substep(poisoner, 1, st_asks(choose_target)).\nother_night_substep(poisoner, 2, player_chooses(target)).\nother_night_substep(poisoner, 3, st_places(poisoned)).\n\n% Poisoner player choice: choose any other player to poison (night 1)\n{ player_chooses(poisoner, Poisoner, point(P), T) : player(P), P != Poisoner } = 1 :-\n    T = night(1, RoleOrd, 2),\n    first_night_role_order(poisoner, RoleOrd),\n    assigned(0, Poisoner, poisoner).\n\n% Poisoner player choice: choose any other player to poison (other nights)\n% Poisoner must be alive to act\n{ player_chooses(poisoner, Poisoner, point(P), T) : player(P), P != Poisoner } = 1 :-\n    T = night(N, RoleOrd, 2),\n    night_number(N), N > 1,\n    other_night_role_order(poisoner, RoleOrd),\n    assigned(0, Poisoner, poisoner),\n    alive(Poisoner, night(N, 0, 0)).\n\n% Poisoner reminder token placement: ST places token on the chosen player (night 1)\nreminder_on(poi_poisoned, P, night(1, RoleOrd, 3)) :-\n    first_night_role_order(poisoner, RoleOrd),\n    player_chooses(poisoner, _, point(P), night(1, RoleOrd, 2)).\n\n% Poisoner reminder token placement: ST places token on the chosen player (other nights)\nreminder_on(poi_poisoned, P, night(N, RoleOrd, 3)) :-\n    night_number(N), N > 1,\n    other_night_role_order(poisoner, RoleOrd),\n    player_chooses(poisoner, _, point(P), night(N, RoleOrd, 2)).\n\n% Remove old poison token at start of night when Poisoner picks new target\n% The new token placement overwrites this via the explicit rule above\ntoken_removed(poi_poisoned, P, night(N, 0, 0)) :-\n    night_number(N), N > 1,\n    reminder_on(poi_poisoned, P, day(N-1, exec)),\n    assigned(0, _, poisoner).\n\n% Token removal blocks inertia\n:- reminder_on(poi_poisoned, P, T), token_removed(poi_poisoned, P, T).\n\n% The poisoner's token causes impairment\ncauses_impairment(poi_poisoned).\n\n% Washerwoman: ST places tokens then tells info\nfirst_night_substep(washerwoman, 1, st_places(ww_townsfolk)).\nfirst_night_substep(washerwoman, 2, st_places(ww_wrong)).\nfirst_night_substep(washerwoman, 3, st_tells(ww_info)).\n\n% Washerwoman reminder token placement\n% At substep 1, ST chooses a player to put the \"townsfolk\" token on\n% At substep 2, ST chooses a different player to put the \"wrong\" token on\n\n% The storyteller chooses where to place these tokens\n{ reminder_on(ww_townsfolk, P, night(1, RoleOrd, 1)) : player(P) } = 1 :-\n    first_night_role_order(washerwoman, RoleOrd),\n    assigned(0, _, washerwoman).\n\n{ reminder_on(ww_wrong, P, night(1, RoleOrd, 2)) : player(P) } = 1 :-\n    first_night_role_order(washerwoman, RoleOrd),\n    assigned(0, _, washerwoman).\n\n% The two tokens must be on different players\n:- reminder_on(ww_townsfolk, P, T1),\n   reminder_on(ww_wrong, P, T2).\n\n% Washerwoman validity constraint:\n% If washerwoman is functioning, the townsfolk token must be on someone\n% who registers as townsfolk at that time\n% FIXME: Due to reminder token inertia, this constraint applies at ALL times\n% the token exists, not just when the washerwoman receives info. We probably\n% only care about the time when st_tells(ww_info) occurs.\n:- reminder_on(ww_townsfolk, P, T),\n   assigned(0, WasherwomanPlayer, washerwoman),\n   functioning(WasherwomanPlayer, T),\n   not registers_as(P, townsfolk, T).\n\n% Washerwoman st_tells: ST points to two players and names a role\n% Uses tuple info(P1, P2, Role) where P1 is the townsfolk, P2 is the wrong player\n\n% A player can register as role R if:\n% - R is their actual assigned role, OR\n% - They can misregister as R's category (spy/recluse only)\n\n% Everyone can register as their actual role\nmay_register_as_role(P, R, T) :-\n    assigned(0, P, R),\n    time(T).\n\n% Spy/Recluse can register as any role in a category they may misregister as\nmay_register_as_role(P, R, T) :-\n    townsfolk(R),\n    may_misregister_as(P, townsfolk),\n    time(T).\n\n% When functioning, role must match what ww_townsfolk player can register as\n% Player order in info tuple is normalized by chair (smaller first)\n{ st_tells_core(washerwoman, WW, info(First, Second, R), T) : may_register_as_role(PTownsfolk, R, T) } = 1 :-\n    T = night(1, RoleOrd, 3),\n    first_night_role_order(washerwoman, RoleOrd),\n    assigned(0, WW, washerwoman),\n    reminder_on(ww_townsfolk, PTownsfolk, T),\n    reminder_on(ww_wrong, PWrong, T),\n    chair_ordered(PTownsfolk, PWrong, First, Second),\n    functioning(WW, T).\n\n% When malfunctioning, ST can say any townsfolk role\n{ st_tells_core(washerwoman, WW, info(First, Second, R), T) : townsfolk(R) } = 1 :-\n    T = night(1, RoleOrd, 3),\n    first_night_role_order(washerwoman, RoleOrd),\n    assigned(0, WW, washerwoman),\n    reminder_on(ww_townsfolk, PTownsfolk, T),\n    reminder_on(ww_wrong, PWrong, T),\n    chair_ordered(PTownsfolk, PWrong, First, Second),\n    not functioning(WW, T).\n\n% ===========================================================================\n% Librarian: like Washerwoman but for outsiders\n% ===========================================================================\nfirst_night_substep(librarian, 1, st_places(lib_outsider)).\nfirst_night_substep(librarian, 2, st_places(lib_wrong)).\nfirst_night_substep(librarian, 3, st_tells(lib_info)).\n\n{ reminder_on(lib_outsider, P, night(1, RoleOrd, 1)) : player(P) } = 1 :-\n    first_night_role_order(librarian, RoleOrd),\n    assigned(0, _, librarian).\n\n{ reminder_on(lib_wrong, P, night(1, RoleOrd, 2)) : player(P) } = 1 :-\n    first_night_role_order(librarian, RoleOrd),\n    assigned(0, _, librarian).\n\n% The two tokens must be on different players\n:- reminder_on(lib_outsider, P, _),\n   reminder_on(lib_wrong, P, _).\n\n% If librarian is functioning, the outsider token must be on someone\n% who registers as outsider at that time\n% FIXME: Same issue as washerwoman - applies at all times, not just info time\n:- reminder_on(lib_outsider, P, T),\n   assigned(0, LibrarianPlayer, librarian),\n   functioning(LibrarianPlayer, T),\n   not registers_as(P, outsider, T).\n\n% Librarian st_tells: ST points to two players and names a role\n% Player order in info tuple is normalized by chair (smaller first)\n\n% Spy/Recluse can register as any outsider role\nmay_register_as_role(P, R, T) :-\n    outsider(R),\n    may_misregister_as(P, outsider),\n    time(T).\n\n% When functioning, role must match what lib_outsider player can register as\n{ st_tells_core(librarian, LIB, info(First, Second, R), T) : may_register_as_role(POutsider, R, T) } = 1 :-\n    T = night(1, RoleOrd, 3),\n    first_night_role_order(librarian, RoleOrd),\n    assigned(0, LIB, librarian),\n    reminder_on(lib_outsider, POutsider, T),\n    reminder_on(lib_wrong, PWrong, T),\n    chair_ordered(POutsider, PWrong, First, Second),\n    functioning(LIB, T).\n\n% When malfunctioning, ST can say any outsider role\n{ st_tells_core(librarian, LIB, info(First, Second, R), T) : outsider(R) } = 1 :-\n    T = night(1, RoleOrd, 3),\n    first_night_role_order(librarian, RoleOrd),\n    assigned(0, LIB, librarian),\n    reminder_on(lib_outsider, POutsider, T),\n    reminder_on(lib_wrong, PWrong, T),\n    chair_ordered(POutsider, PWrong, First, Second),\n    not functioning(LIB, T).\n\n% ===========================================================================\n% Investigator: like Washerwoman but for minions\n% ===========================================================================\nfirst_night_substep(investigator, 1, st_places(inv_minion)).\nfirst_night_substep(investigator, 2, st_places(inv_wrong)).\nfirst_night_substep(investigator, 3, st_tells(inv_info)).\n\n{ reminder_on(inv_minion, P, night(1, RoleOrd, 1)) : player(P) } = 1 :-\n    first_night_role_order(investigator, RoleOrd),\n    assigned(0, _, investigator).\n\n{ reminder_on(inv_wrong, P, night(1, RoleOrd, 2)) : player(P) } = 1 :-\n    first_night_role_order(investigator, RoleOrd),\n    assigned(0, _, investigator).\n\n% The two tokens must be on different players\n:- reminder_on(inv_minion, P, _),\n   reminder_on(inv_wrong, P, _).\n\n% If investigator is functioning, the minion token must be on someone\n% who registers as minion at that time\n% FIXME: Same issue as washerwoman - applies at all times, not just info time\n:- reminder_on(inv_minion, P, T),\n   assigned(0, InvestigatorPlayer, investigator),\n   functioning(InvestigatorPlayer, T),\n   not registers_as(P, minion, T).\n\n% Investigator st_tells: ST points to two players and names a role\n% Player order in info tuple is normalized by chair (smaller first)\n\n% Recluse can register as any minion role\nmay_register_as_role(P, R, T) :-\n    minion(R),\n    may_misregister_as(P, minion),\n    time(T).\n\n% Recluse can register as any demon role\nmay_register_as_role(P, R, T) :-\n    demon(R),\n    may_misregister_as(P, demon),\n    time(T).\n\n% When functioning, role must match what inv_minion player can register as\n{ st_tells_core(investigator, INV, info(First, Second, R), T) : may_register_as_role(PMinion, R, T) } = 1 :-\n    T = night(1, RoleOrd, 3),\n    first_night_role_order(investigator, RoleOrd),\n    assigned(0, INV, investigator),\n    reminder_on(inv_minion, PMinion, T),\n    reminder_on(inv_wrong, PWrong, T),\n    chair_ordered(PMinion, PWrong, First, Second),\n    functioning(INV, T).\n\n% When malfunctioning, ST can say any minion role\n{ st_tells_core(investigator, INV, info(First, Second, R), T) : minion(R) } = 1 :-\n    T = night(1, RoleOrd, 3),\n    first_night_role_order(investigator, RoleOrd),\n    assigned(0, INV, investigator),\n    reminder_on(inv_minion, PMinion, T),\n    reminder_on(inv_wrong, PWrong, T),\n    chair_ordered(PMinion, PWrong, First, Second),\n    not functioning(INV, T).\n\n% ===========================================================================\n% Chef: learns how many pairs of evil players are neighbors\n% ===========================================================================\nfirst_night_substep(chef, 1, st_tells(chef_info)).\n\n% Chef info is derived from grimoire state, no reminder tokens needed\n% The ST tells the chef a number; if functioning, it must be accurate\n\n% An \"evil pair\" is two neighboring players who both register as evil\n% We count ordered pairs where P1 < P2 (by chair) to avoid double-counting\nevil_pair(P1, P2, T) :-\n    neighbor(P1, P2),\n    chair(P1, C1), chair(P2, C2), C1 < C2,\n    registers_as(P1, evil, T),\n    registers_as(P2, evil, T).\n\n% Count the number of evil pairs at time T\nevil_pair_count(N, T) :-\n    time(T),\n    N = #count { P1, P2 : evil_pair(P1, P2, T) }.\n\n% Chef st_tells: ST tells the chef a count\n% When functioning, the count must match the actual evil_pair_count\nst_tells_core(chef, Chef, count(N), T) :-\n    T = night(1, RoleOrd, 1),\n    first_night_role_order(chef, RoleOrd),\n    assigned(0, Chef, chef),\n    functioning(Chef, T),\n    evil_pair_count(N, T).\n\n% When malfunctioning, ST can tell any count from 0 to player_count/2\n{ st_tells_core(chef, Chef, count(N), T) : N = 0..player_count/2 } = 1 :-\n    T = night(1, RoleOrd, 1),\n    first_night_role_order(chef, RoleOrd),\n    assigned(0, Chef, chef),\n    not functioning(Chef, T).\n\n% ===========================================================================\n% Empath: learns how many of their living neighbors are evil\n% Living neighbors = closest alive player in each direction (skips dead)\n% ===========================================================================\nfirst_night_substep(empath, 1, st_tells(empath_info)).\nother_night_substep(empath, 1, st_tells(empath_info)).\n\n% Empath info is derived from grimoire state, no reminder tokens needed\n% The ST tells the empath a number; if functioning, it must be accurate\n\n% Count how many of the empath's living neighbors register as evil\nempath_evil_neighbor_count(Empath, N, T) :-\n    assigned(0, Empath, empath),\n    time(T),\n    N = #count { P : living_neighbor(Empath, P, T), registers_as(P, evil, T) }.\n\n% Empath st_tells: ST tells the empath a count (0, 1, or 2)\n% When functioning, the count must match the actual neighbor evil count\nst_tells_core(empath, Empath, count(N), T) :-\n    acting_role(T, empath),\n    assigned(0, Empath, empath),\n    alive(Empath, T),\n    functioning(Empath, T),\n    empath_evil_neighbor_count(Empath, N, T).\n\n% When malfunctioning, ST can tell any count from 0 to 2\n{ st_tells_core(empath, Empath, count(N), T) : N = 0..2 } = 1 :-\n    acting_role(T, empath),\n    assigned(0, Empath, empath),\n    alive(Empath, T),\n    not functioning(Empath, T).\n\n% ===========================================================================\n% Undertaker: learns the role of the player executed the previous day\n% Acts on other nights only (not night 1)\n% ===========================================================================\nother_night_substep(undertaker, 1, st_tells(undertaker_info)).\n\n% Helper: who was executed on the previous day\nexecuted_previous_day(P, N) :-\n    night_number(N), N > 1,\n    executed(P, N-1).\n\n% When functioning, ST may tell any role the executed player registers as\nst_may_tell(undertaker, UT, point(R), night(N, RoleOrd, 1)) :-\n    night_number(N), N > 1,\n    other_night_role_order(undertaker, RoleOrd),\n    assigned(0, UT, undertaker),\n    alive(UT, night(N, 0, 0)),\n    functioning(UT, night(N, RoleOrd, 1)),\n    executed_previous_day(P, N),\n    may_register_as_role(P, R, night(N, RoleOrd, 1)).\n\n% When malfunctioning, ST may tell any role\nst_may_tell(undertaker, UT, point(R), night(N, RoleOrd, 1)) :-\n    night_number(N), N > 1,\n    other_night_role_order(undertaker, RoleOrd),\n    assigned(0, UT, undertaker),\n    alive(UT, night(N, 0, 0)),\n    not functioning(UT, night(N, RoleOrd, 1)),\n    executed_previous_day(_, N),\n    role(R).\n\n% ST picks exactly one from what they may tell\n{ st_tells_core(undertaker, UT, Msg, T) : st_may_tell(undertaker, UT, Msg, T) } = 1 :-\n    night_number(N), N > 1,\n    other_night_role_order(undertaker, RoleOrd),\n    T = night(N, RoleOrd, 1),\n    assigned(0, UT, undertaker),\n    alive(UT, night(N, 0, 0)),\n    executed_previous_day(_, N).\n\n% If no one was executed the previous day, undertaker gets no info\n% (no st_tells is generated)\n\n% ===========================================================================\n% Ravenkeeper: If you die at night, choose a player to learn their role\n% Only wakes when killed by demon (has imp_dead token)\n% ===========================================================================\nother_night_substep(ravenkeeper, 1, st_asks(choose_player)).\nother_night_substep(ravenkeeper, 2, player_chooses(target)).\nother_night_substep(ravenkeeper, 3, st_tells(rk_info)).\n\n% Ravenkeeper only acts if they were killed tonight (have imp_dead token)\nrk_died_tonight(RK, N) :-\n    assigned(0, RK, ravenkeeper),\n    night_number(N), N > 1,\n    other_night_role_order(ravenkeeper, RoleOrd),\n    reminder_on(imp_dead, RK, night(N, RoleOrd, 1)).\n\n% Ravenkeeper chooses 1 player when dying\n{ rk_choice(RK, P, night(N, RoleOrd, 2)) : player(P) } = 1 :-\n    assigned(0, RK, ravenkeeper),\n    other_night_role_order(ravenkeeper, RoleOrd),\n    night_number(N), N > 1,\n    rk_died_tonight(RK, N).\n\n% Choice persists to substep 3\nrk_choice(RK, P, night(N, RoleOrd, 3)) :-\n    rk_choice(RK, P, night(N, RoleOrd, 2)).\n\n% rk_choice must include player specified via player_chooses\n:- player_chooses(ravenkeeper, RK, point(P), T),\n   not rk_choice(RK, P, T).\n\n% Convert to player_chooses signal\nplayer_chooses(ravenkeeper, RK, point(P), T) :-\n    rk_choice(RK, P, T).\n\n% When functioning, ST tells the ravenkeeper the chosen player's role\nst_tells_core(ravenkeeper, RK, point(R), night(N, RoleOrd, 3)) :-\n    night_number(N), N > 1,\n    other_night_role_order(ravenkeeper, RoleOrd),\n    assigned(0, RK, ravenkeeper),\n    rk_died_tonight(RK, N),\n    functioning(RK, night(N, RoleOrd, 3)),\n    rk_choice(RK, P, night(N, RoleOrd, 3)),\n    may_register_as_role(P, R, night(N, RoleOrd, 3)).\n\n% When malfunctioning, ST can say any role\n{ st_tells_core(ravenkeeper, RK, point(R), night(N, RoleOrd, 3)) : role(R) } = 1 :-\n    night_number(N), N > 1,\n    other_night_role_order(ravenkeeper, RoleOrd),\n    assigned(0, RK, ravenkeeper),\n    rk_died_tonight(RK, N),\n    not functioning(RK, night(N, RoleOrd, 3)).\n\n% ===========================================================================\n% Fortune Teller: chooses 2 players, learns if either is the demon\n% Acts on first night and every other night\n% ===========================================================================\nfirst_night_substep(fortune_teller, 1, st_asks(choose_two)).\nfirst_night_substep(fortune_teller, 2, player_chooses(two_players)).\nfirst_night_substep(fortune_teller, 3, st_tells(ft_info)).\n\nother_night_substep(fortune_teller, 1, st_asks(choose_two)).\nother_night_substep(fortune_teller, 2, player_chooses(two_players)).\nother_night_substep(fortune_teller, 3, st_tells(ft_info)).\n\n% Other Night Order for Trouble Brewing\n% Role order determines which role acts when (on nights 2+)\nother_night_role_order(poisoner, 1).\nother_night_role_order(monk, 2).\nother_night_role_order(scarlet_woman, 3).\nother_night_role_order(imp, 4).\nother_night_role_order(ravenkeeper, 5).\nother_night_role_order(empath, 6).\nother_night_role_order(fortune_teller, 7).\nother_night_role_order(undertaker, 8).\nother_night_role_order(butler, 9).\nother_night_role_order(spy, 10).\n\n% Fortune teller has a \"red herring\" - one player who always registers as demon to them\n% This is placed during setup, not during the fortune teller's turn\n\n{ reminder_on(ft_red_herring, P, night(1, 0, 0)) : player(P) } = 1 :-\n    assigned(0, _, fortune_teller).\n\n% Red herring cannot be on the actual demon\n:- reminder_on(ft_red_herring, P, _),\n   assigned(0, P, R),\n   demon(R).\n\n% Red herring must be on a good player (townsfolk or outsider)\n:- reminder_on(ft_red_herring, P, T),\n   not registers_as(P, good, T).\n\n% Fortune teller chooses 2 different players (unordered set)\n% ft_choice(FT, P, T) means FT chose player P at time T\n% Choice happens at substep 2 only\n{ ft_choice(FT, P, night(N, RoleOrd, 2)) : player(P) } = 2 :-\n    assigned(0, FT, fortune_teller),\n    first_night_role_order(fortune_teller, RoleOrd),\n    N = 1.\n\n{ ft_choice(FT, P, night(N, RoleOrd, 2)) : player(P) } = 2 :-\n    assigned(0, FT, fortune_teller),\n    other_night_role_order(fortune_teller, RoleOrd),\n    night_number(N), N > 1.\n\n% Choice persists from substep 2 to substep 3 (when ST tells result)\nft_choice(FT, P, night(N, RoleOrd, 3)) :-\n    ft_choice(FT, P, night(N, RoleOrd, 2)).\n\n% ft_choice must include any players specified via player_chooses\n:- player_chooses(fortune_teller, FT, point(P), T),\n   not ft_choice(FT, P, T).\n\n% Convert to player_chooses signals (one for each chosen player)\nplayer_chooses(fortune_teller, FT, point(P), T) :-\n    ft_choice(FT, P, T).\n\n% A player \"pings as demon\" to the fortune teller if:\n% - They register as demon (actual demon or Recluse), OR\n% - They have the red herring token\nft_pings_as_demon(P, T) :-\n    registers_as(P, demon, T).\n\nft_pings_as_demon(P, T) :-\n    reminder_on(ft_red_herring, P, T).\n\n% Helper: FT got a ping if any chosen player pings\nft_got_ping(FT, T) :-\n    ft_choice(FT, P, T),\n    ft_pings_as_demon(P, T).\n\n% Fortune teller st_tells: yes if either chosen player pings as demon\n% Only at substep 3 (after player has chosen)\n% When functioning: answer must be accurate\nst_tells_core(fortune_teller, FT, yes, night(N, RoleOrd, 3)) :-\n    first_night_role_order(fortune_teller, RoleOrd), N = 1,\n    assigned(0, FT, fortune_teller),\n    functioning(FT, night(N, RoleOrd, 3)),\n    ft_got_ping(FT, night(N, RoleOrd, 3)).\n\nst_tells_core(fortune_teller, FT, yes, night(N, RoleOrd, 3)) :-\n    other_night_role_order(fortune_teller, RoleOrd), night_number(N), N > 1,\n    assigned(0, FT, fortune_teller),\n    functioning(FT, night(N, RoleOrd, 3)),\n    ft_got_ping(FT, night(N, RoleOrd, 3)).\n\nst_tells_core(fortune_teller, FT, no, night(N, RoleOrd, 3)) :-\n    first_night_role_order(fortune_teller, RoleOrd), N = 1,\n    assigned(0, FT, fortune_teller),\n    functioning(FT, night(N, RoleOrd, 3)),\n    not ft_got_ping(FT, night(N, RoleOrd, 3)).\n\nst_tells_core(fortune_teller, FT, no, night(N, RoleOrd, 3)) :-\n    other_night_role_order(fortune_teller, RoleOrd), night_number(N), N > 1,\n    assigned(0, FT, fortune_teller),\n    functioning(FT, night(N, RoleOrd, 3)),\n    not ft_got_ping(FT, night(N, RoleOrd, 3)).\n\n% When malfunctioning: ST can say yes or no\n{ st_tells_core(fortune_teller, FT, yes, night(N, RoleOrd, 3)) ;\n  st_tells_core(fortune_teller, FT, no, night(N, RoleOrd, 3)) } = 1 :-\n    first_night_role_order(fortune_teller, RoleOrd), N = 1,\n    assigned(0, FT, fortune_teller),\n    not functioning(FT, night(N, RoleOrd, 3)).\n\n{ st_tells_core(fortune_teller, FT, yes, night(N, RoleOrd, 3)) ;\n  st_tells_core(fortune_teller, FT, no, night(N, RoleOrd, 3)) } = 1 :-\n    other_night_role_order(fortune_teller, RoleOrd), night_number(N), N > 1,\n    assigned(0, FT, fortune_teller),\n    not functioning(FT, night(N, RoleOrd, 3)).\n\n% ===========================================================================\n% Butler: chooses a master each night\n% ===========================================================================\nfirst_night_substep(butler, 1, st_asks(choose_master)).\nfirst_night_substep(butler, 2, player_chooses(master)).\nfirst_night_substep(butler, 3, st_places(but_master)).\n\n% Butler player choice: choose any other player as master\n{ player_chooses(butler, Butler, point(P), T) : player(P), P != Butler } = 1 :-\n    T = night(1, RoleOrd, 2),\n    first_night_role_order(butler, RoleOrd),\n    assigned(0, Butler, butler).\n\n% Butler reminder token placement: ST places token on the chosen master\nreminder_on(but_master, P, night(1, RoleOrd, 3)) :-\n    first_night_role_order(butler, RoleOrd),\n    player_chooses(butler, _, point(P), night(1, RoleOrd, 2)).\n\n% ===========================================================================\n% Slayer: once per game, publicly chooses a player; if registers as demon, they die\n% ===========================================================================\n\n% slayer_shot(Slayer, Target, Day) - Slayer uses ability on Target during Day\n% This is input from the scenario\n\n% Validate: Slayer must be assigned the slayer role\n:- slayer_shot(Slayer, _, _), not assigned(0, Slayer, slayer).\n\n% Validate: Both must be alive at start of day\n:- slayer_shot(Slayer, _, N), not alive(Slayer, day(N, 0)).\n:- slayer_shot(_, Target, N), not alive(Target, day(N, 0)).\n\n% Slayer gets \"no ability\" token when they use their shot (regardless of functioning)\n% This happens even if drunk/poisoned - the shot is still \"used\"\nreminder_on(sla_no_ability, Slayer, day(N, 0)) :- slayer_shot(Slayer, _, N).\n\n% Slayer can only use ability once (enforced by reminder token)\n:- slayer_shot(Slayer, _, N),\n   reminder_on(sla_no_ability, Slayer, T),\n   T = day(N2, _), N2 < N.\n\n% Slayer ability: if Slayer is functioning AND target registers as demon, target dies\n% Note: For Recluse, registers_as(recluse, demon, T) is a CHOICE - ST decides\n% So Recluse CAN die (if ST chooses demon registration) but doesn't HAVE to\ndied(Target, day(N, 0)) :-\n    slayer_shot(Slayer, Target, N),\n    functioning(Slayer, day(N, 0)),\n    registers_as(Target, demon, day(N, 0)).\n\n% ===========================================================================\n% Imp: each night (except the first), chooses a player to kill\n% ===========================================================================\nother_night_substep(imp, 1, st_asks(choose_target)).\nother_night_substep(imp, 2, player_chooses(kill_target)).\nother_night_substep(imp, 3, st_places(imp_dead)).\n\n% Imp player choice: choose any player to kill (can choose self for starpass)\n% Imp must be alive to act\n% Note: We check current_demon to handle Scarlet Woman becoming the Imp\n{ player_chooses(imp, Imp, point(P), T) : player(P) } = 1 :-\n    T = night(N, RoleOrd, 2),\n    night_number(N), N > 1,\n    other_night_role_order(imp, RoleOrd),\n    current_demon(Imp, N),\n    alive(Imp, night(N, 0, 0)).\n\n% Helper: who is the demon at the start of night N\n% By default, it's whoever was assigned at time 0\ncurrent_demon(P, N) :-\n    night_number(N),\n    assigned(0, P, R),\n    demon(R),\n    not replaced_as_demon(P, N).\n\n% The original demon is replaced starting from night after Scarlet Woman triggers\nreplaced_as_demon(P, N) :-\n    assigned(0, P, R),\n    demon(R),\n    sw_becomes_demon(_, TriggerDay),\n    night_number(N),\n    N > TriggerDay.\n\n% Scarlet Woman becomes the current demon starting from night after she triggers\ncurrent_demon(SW, N) :-\n    sw_becomes_demon(SW, TriggerDay),\n    night_number(N),\n    N > TriggerDay.\n\n% Imp places \"dead\" token on chosen target (if imp is functioning)\n% Token is placed regardless of protection - protection blocks the death, not the targeting\n% Token is NOT placed if imp is drunk/poisoned\nreminder_on(imp_dead, Target, night(N, RoleOrd, 3)) :-\n    night_number(N), N > 1,\n    other_night_role_order(imp, RoleOrd),\n    player_chooses(imp, Imp, point(Target), night(N, RoleOrd, 2)),\n    functioning(Imp, night(N, RoleOrd, 3)).\n\n% Dead players (with imp_dead token) don't wake up, but this is handled\n% by checking `alive` in ability rules, not by impairment.\n% Ravenkeeper is special: their ability triggers because of imp_dead.\n\n% imp_kill_succeeds(P, T) is true when the imp's kill attempt actually takes effect\n% (i.e., they have imp_dead token AND are NOT protected)\n% This is defined AFTER protected_from_demon (see Monk section below)\n\n% At dawn (end of night), the death becomes public - player dies\n% But only if not protected from demon\ndied(P, T) :-\n    final_night_time(N, T),\n    imp_kill_succeeds(P, T).\n\n% dead(P, T) for imp kills - defined after protected_from_demon\n% (see Monk section below for imp_kill_succeeds definition)\n\n% ===========================================================================\n% Monk: protects a player from the demon (other nights only)\n% ===========================================================================\nother_night_substep(monk, 1, st_asks(choose_target)).\nother_night_substep(monk, 2, player_chooses(target)).\nother_night_substep(monk, 3, st_places(monk_protected)).\n\n% Monk chooses a player to protect (cannot choose self)\n{ player_chooses(monk, Monk, point(P), night(N, RoleOrd, 2)) : player(P), P != Monk } = 1 :-\n    night_number(N), N > 1,\n    other_night_role_order(monk, RoleOrd),\n    assigned(0, Monk, monk),\n    alive(Monk, night(N, 0, 0)),\n    functioning(Monk, night(N, RoleOrd, 2)).\n\n% If monk is drunk/poisoned, they still choose but it has no effect\n% (we still need them to choose so the game flow continues)\n{ player_chooses(monk, Monk, point(P), night(N, RoleOrd, 2)) : player(P), P != Monk } = 1 :-\n    night_number(N), N > 1,\n    other_night_role_order(monk, RoleOrd),\n    assigned(0, Monk, monk),\n    alive(Monk, night(N, 0, 0)),\n    not functioning(Monk, night(N, RoleOrd, 2)).\n\n% Monk reminder token placement\nreminder_on(monk_protected, P, night(N, RoleOrd, 3)) :-\n    night_number(N), N > 1,\n    other_night_role_order(monk, RoleOrd),\n    player_chooses(monk, Monk, point(P), night(N, RoleOrd, 2)),\n    assigned(0, Monk, monk),\n    functioning(Monk, night(N, RoleOrd, 2)).\n\n% Protection only lasts for the night - remove at start of next night\ntoken_removed(monk_protected, P, night(N, 0, 0)) :-\n    night_number(N), N > 1,\n    reminder_on(monk_protected, P, day(N-1, exec)).\n\n:- reminder_on(monk_protected, P, T), token_removed(monk_protected, P, T).\n\n% A player with the monk_protected token is protected from demon kills\nprotected_from_demon(P, T) :- reminder_on(monk_protected, P, T).\n\n% imp_kill_succeeds: the imp's kill takes effect (target has imp_dead and is not protected)\nimp_kill_succeeds(P, T) :-\n    reminder_on(imp_dead, P, T),\n    not protected_from_demon(P, T).\n\n% A player is \"dead\" (for ST mechanics) during the night when imp kill succeeds\ndead(P, T) :- imp_kill_succeeds(P, T).\n\n% ===========================================================================\n% Spy: sees the grimoire (no mechanical effect to model here)\n% ===========================================================================\nfirst_night_substep(spy, 1, st_shows(grimoire)).\n\n% ===========================================================================\n% Spy and Recluse mis-registration\n% ===========================================================================\n\n% Spy can register as good and/or as townsfolk/outsider\n% (Spy is already evil and a minion, so no misregistration needed for those)\nmay_mis_register(P) :- assigned(0, P, spy).\nmay_misregister_as(P, good) :- assigned(0, P, spy).\nmay_misregister_as(P, townsfolk) :- assigned(0, P, spy).\nmay_misregister_as(P, outsider) :- assigned(0, P, spy).\n\n% Recluse can register as evil and/or as minion/demon\n% (Recluse is already good and an outsider, so no misregistration needed for those)\nmay_mis_register(P) :- assigned(0, P, recluse).\nmay_misregister_as(P, evil) :- assigned(0, P, recluse).\nmay_misregister_as(P, minion) :- assigned(0, P, recluse).\nmay_misregister_as(P, demon) :- assigned(0, P, recluse).\n\n% ===========================================================================\n% Scarlet Woman: becomes the demon if demon is executed with 5+ alive\n% ===========================================================================\n\n% Count alive players at start of day (proxy for \"at time of execution\")\n% TODO: revisit when mid-day deaths are possible\nalive_count(N, C) :-\n    day_number(N),\n    C = #count { P : alive(P, day(N, 0)) }.\n\n% Scarlet Woman triggers when:\n% 1. The demon is executed\n% 2. 5+ players were alive\n% 3. Scarlet Woman is alive\nsw_becomes_demon(SW, N) :-\n    assigned(0, SW, scarlet_woman),\n    assigned(0, Demon, R), demon(R),\n    executed(Demon, N),\n    alive_count(N, C), C >= 5,\n    alive(SW, day(N, 0)).\n\n% When Scarlet Woman becomes demon, she gains the Imp role\nassigned(N, SW, imp) :- sw_becomes_demon(SW, N).\n\n% ===========================================================================\n% Reminder Token Metadata (for grimoire rendering)\n% ===========================================================================\n\n% reminder_belongs_to(Token, Role) - which role owns this reminder token\nreminder_belongs_to(drunk_is_drunk, drunk).\nreminder_belongs_to(poi_poisoned, poisoner).\nreminder_belongs_to(ww_townsfolk, washerwoman).\nreminder_belongs_to(ww_wrong, washerwoman).\nreminder_belongs_to(lib_outsider, librarian).\nreminder_belongs_to(lib_wrong, librarian).\nreminder_belongs_to(inv_minion, investigator).\nreminder_belongs_to(inv_wrong, investigator).\nreminder_belongs_to(ft_red_herring, fortune_teller).\nreminder_belongs_to(but_master, butler).\nreminder_belongs_to(sla_no_ability, slayer).\nreminder_belongs_to(monk_protected, monk).\nreminder_belongs_to(imp_dead, imp).\n\n% reminder_label(Token, Label) - human-readable label for grimoire display\nreminder_label(drunk_is_drunk, \"Is the Drunk\").\nreminder_label(poi_poisoned, \"Poisoned\").\nreminder_label(ww_townsfolk, \"Townsfolk\").\nreminder_label(ww_wrong, \"Wrong\").\nreminder_label(lib_outsider, \"Outsider\").\nreminder_label(lib_wrong, \"Wrong\").\nreminder_label(inv_minion, \"Minion\").\nreminder_label(inv_wrong, \"Wrong\").\nreminder_label(ft_red_herring, \"Red herring\").\nreminder_label(but_master, \"Master\").\nreminder_label(sla_no_ability, \"No ability\").\nreminder_label(monk_protected, \"Protected\").\nreminder_label(imp_dead, \"Dead\").\n\n";
export const playersLp = "name(amanda; rob; taylor; courtney; neha; pratik; steph; felix).\nname(kunjal; cyrielle; logan; lou; kate; ivan; ricky; kyla).\n\nchair(amanda, 0).\nchair(rob, 1).\nchair(taylor, 2).\nchair(courtney, 3).\nchair(steph, 4).\nchair(felix, 5).\nchair(neha, 6).\nchair(pratik, 7).\nchair(kunjal, 8).\nchair(cyrielle, 9).\nchair(logan, 10).\nchair(lou, 11).\nchair(kate, 12).\nchair(ivan, 13).\nchair(ricky, 14).\nchair(kyla, 15).\n";
export const instLp = "#include \"botc.lp\".\n#include \"tb.lp\".\n#include \"players.lp\".\n\n#const player_count = 8.\n% We are demoing three nights, so we write needs_night(3).\nneeds_night(3).\nassigned(0, felix, drunk).\nassigned(0, amanda, poisoner).\nassigned(0, rob, washerwoman).\nassigned(0, taylor, librarian).\nassigned(0, courtney, investigator).\n\n% ===========================================================================\n% Example: Player-visible constraints using simplified st_tells\n% ===========================================================================\n% The simplified st_tells predicates let you express what players observed\n% without needing implementation details like timestamps or wrapper terms.\n%\n% Info values are unwrapped for convenience:\n%   count(N) -> N      (chef, empath)\n%   info(P1,P2,R) -> R (washerwoman, librarian, investigator)\n%   point(R) -> R      (undertaker, ravenkeeper)\n%   yes/no -> yes/no   (fortune_teller)\n%\n% --- st_tells/2: for one-time info or when night doesn't matter ---\n%   :- not st_tells(chef, 2).             % chef was told 2\n%   :- not st_tells(washerwoman, chef).   % washerwoman was told \"chef\"\n%   :- not st_tells(undertaker, imp).     % undertaker learned \"imp\"\n%   :- not st_tells(fortune_teller, yes). % FT was told yes (at some point)\n%\n% --- st_tells/3: includes night number for recurring info roles ---\n%   :- not st_tells(empath, 1, 2).          % empath told 1 on night 2\n%   :- not st_tells(fortune_teller, yes, 1). % FT told yes on night 1\n%   :- not st_tells(fortune_teller, no, 3).  % FT told no on night 3\n%   :- not st_tells(undertaker, chef, 2).   % undertaker learned chef on night 2\n%\n% Can also query by player name:\n%   :- not st_tells(amanda, 2).      % amanda was told 2\n%   :- not st_tells(amanda, 1, 2).   % amanda was told 1 on night 2\n%\n% These derive from st_tells_core(Role, Player, Info, Time), the detailed form.\n% ===========================================================================\n\n#show distrib/1.\n#show assigned/3.\n%#show received/2.\n%#show time/1.\n%#show next/2.\n#show reminder_on/3.\n%#show impaired/2.\n#show registers_as/3.\n\n% For grimoire/timeline rendering\n#show game_chair/2.\n#show alive/2.\n#show st_tells/4.\n#show player_chooses/4.\n";
export const typesLp = "% ===========================================================================\n% Domain constraints (\"type checking\")\n% These catch errors like typos in player names or invalid roles.\n% ===========================================================================\n\n% --- Player name validation ---\n:- assigned(0, P, _), not player(P).\n:- reminder_on(_, P, _), not player(P).\n:- player_chooses(_, P, _, _), not player(P).\n:- st_tells_core(_, P, _, _), not player(P).\n:- slayer_shot(P, _, _), not player(P).\n:- slayer_shot(_, P, _), not player(P).\n:- executed(P, _), not player(P).\n:- died(P, _), not player(P).\n:- alive(P, _), not player(P).\n:- functioning(P, _), not player(P).\n:- impaired(P, _), not player(P).\n\n% --- Role name validation ---\n:- assigned(0, _, R), not role(R).\n:- acting_role(_, R), not role(R).\n:- first_night_role_order(R, _), not role(R).\n:- other_night_role_order(R, _), not role(R).\n:- player_chooses(R, _, _, _), not role(R).\n:- st_tells_core(R, _, _, _), not role(R).\n\n% --- Time validation ---\n:- reminder_on(_, _, T), not time(T).\n:- player_chooses(_, _, _, T), not time(T).\n:- st_tells_core(_, _, _, T), not time(T).\n:- alive(_, T), not time(T).\n:- died(_, T), not time(T).\n:- functioning(_, T), not time(T).\n";
